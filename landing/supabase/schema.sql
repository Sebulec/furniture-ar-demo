-- Create a table for storing generation history
create type generation_status as enum ('processing', 'completed', 'failed');

create table public.generations (
  id uuid not null default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  input_image_url text not null,
  glb_url text,
  usdz_url text,
  status generation_status not null default 'processing',
  name text,
  created_at timestamp with time zone not null default now(),
  primary key (id)
);

-- Enable RLS
alter table public.generations enable row level security;

-- Policies
create policy "Users can view their own generations"
  on public.generations for select
  using (auth.uid() = user_id);

create policy "Users can insert their own generations"
  on public.generations for insert
  with check (auth.uid() = user_id);

create policy "Users can update their own generations"
  on public.generations for update
  using (auth.uid() = user_id);

create policy "Users can delete their own generations"
  on public.generations for delete
  using (auth.uid() = user_id);

-- Analytics table for tracking AR viewer events
create table if not exists public.analytics (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default timezone('utc'::text, now()),
  event_type text not null,
  user_id text null,
  model_name text null,
  metadata jsonb null,
  constraint analytics_pkey primary key (id)
) tablespace pg_default;

create index if not exists idx_analytics_event on public.analytics using btree (event_type) tablespace pg_default;
create index if not exists idx_analytics_created on public.analytics using btree (created_at) tablespace pg_default;

-- Enable RLS for analytics (but allow public inserts from AR viewer)
alter table public.analytics enable row level security;

-- Allow anyone to insert analytics events (for AR viewer tracking)
create policy if not exists "Anyone can insert analytics events"
  on public.analytics for insert
  with check (true);

-- Only allow reading analytics via service role (API route handles auth)
create policy if not exists "Service role can read analytics"
  on public.analytics for select
  using (false); -- This forces all reads to go through the API with service role key

-- Storage bucket for uploads
insert into storage.buckets (id, name, public)
values ('uploads', 'uploads', true)
on conflict (id) do nothing;

create policy "Users can upload their own images"
  on storage.objects for insert
  with check ( bucket_id = 'uploads' and auth.uid() = owner );

create policy "Public access to uploads"
  on storage.objects for select
  using ( bucket_id = 'uploads' );
